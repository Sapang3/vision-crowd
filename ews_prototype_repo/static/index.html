
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>EWS Prototype Dashboard - Simhasth 2028</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }
    
    .header {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
      color: white;
      padding: 20px 0;
      text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    .header h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .header p {
      font-size: 1.2em;
      opacity: 0.9;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .card { 
      background: white;
      border-radius: 15px; 
      padding: 15px; 
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 40px rgba(0,0,0,0.15);
    }
    
    .status-card {
      grid-column: 1 / -1;
    }
    
    .alert { 
      font-weight: bold; 
      font-size: 1.3em; 
      padding: 10px 20px; 
      border-radius: 8px; 
      display: inline-block;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    .green { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; }
    .yellow { background: linear-gradient(135deg, #FFC107, #FF8F00); color: white; }
    .orange { background: linear-gradient(135deg, #FF9800, #F57C00); color: white; }
    .red { background: linear-gradient(135deg, #F44336, #D32F2F); color: white; }
    
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
      margin: 15px 0;
    }
    
    .metric {
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      padding: 10px;
      border-radius: 8px;
      text-align: center;
      border-left: 4px solid #667eea;
    }
    
    .metric-label {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .metric-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #333;
    }
    
    .chart-container {
      background: white;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      margin-bottom: 10px;
    }
    
    .chart-title {
      font-size: 1.5em;
      margin-bottom: 20px;
      color: #333;
      text-align: center;
      font-weight: 600;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    
    .btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    
    .btn.active {
      background: linear-gradient(135deg, #ff6b6b, #ee5a24);
    }
    
    .footer {
      text-align: center;
      padding: 20px;
      color: white;
      opacity: 0.8;
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }
    
    .status-indicator.online { background: #4CAF50; }
    .status-indicator.offline { background: #F44336; }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    .real-time-badge {
      background: linear-gradient(135deg, #4CAF50, #45a049);
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 0.8em;
      display: inline-block;
      margin-left: 10px;
      animation: pulse 2s infinite;
    }
    
    .metric-value {
      transition: all 0.3s ease;
    }
    
    .metric-value.updating {
      animation: valueChange 0.5s ease;
    }
    
    @keyframes valueChange {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); color: #ff6b6b; }
      100% { transform: scale(1); }
    }
    
    .chart-container {
      position: relative;
    }
    
    .chart-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 49%, rgba(255,255,255,0.1) 50%, transparent 51%);
      background-size: 20px 20px;
      animation: chartShimmer 3s linear infinite;
      pointer-events: none;
    }
    
    @keyframes chartShimmer {
      0% { background-position: 0 0; }
      100% { background-position: 20px 20px; }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>ðŸš¨ Early Warning System</h1>
    <p>Simhasth 2028 - Crowd Management Dashboard</p>
    <div class="real-time-badge">LIVE</div>
  </div>
  
  <div class="container">
    <div class="dashboard-grid">
      <div id="status" class="card">
        <h3><span class="status-indicator online"></span>Current Status</h3>
        <div class="metric-grid">
          <div class="metric">
            <div class="metric-label">Timestamp</div>
            <div class="metric-value" id="ts">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">Phase</div>
            <div class="metric-value" id="phase">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">Risk Level</div>
            <div class="metric-value" id="risk">-</div>
          </div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
          <span id="alert" class="alert green">-</span>
        </div>
      </div>

      <div class="card">
        <h3>Physical Indices</h3>
        <div class="metric-grid">
          <div class="metric">
            <div class="metric-label">CAI</div>
            <div class="metric-value" id="cai">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">CDI</div>
            <div class="metric-value" id="cdi">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">THI</div>
            <div class="metric-value" id="thi">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">TI</div>
            <div class="metric-value" id="ti">-</div>
          </div>
          <div class="metric">
            <div class="metric-label">EI</div>
            <div class="metric-value" id="ei">-</div>
          </div>
        </div>
      </div>
    </div>

    <div class="chart-container">
      <h3 class="chart-title">Real-Time Risk Monitoring</h3>
      <div class="controls">
        <button class="btn active" onclick="toggleRealTime()">Real-Time Mode</button>
        <button class="btn" onclick="downloadData()">Download Data</button>
        <button class="btn" onclick="resetChart()">Reset Chart</button>
      </div>
      <canvas id="chart" width="1200" height="300"></canvas>
    </div>

    <div class="footer">
      <p>Early Warning System for Simhasth 2028 | Real-time Crowd Management Dashboard</p>
    </div>
  </div>

<script>
// Global variables for real-time functionality
let realTimeMode = true;
let chartData = [];
let maxDataPoints = 100;

// Store previous values for comparison
let previousValues = {};

async function fetchStatus() {
  try {
    const r = await fetch('/status');
    const j = await r.json();
    
    // Update timestamp with better formatting
    const timestamp = new Date(j.timestamp);
    document.getElementById('ts').textContent = timestamp.toLocaleString();
    
    // Update phase with animation
    updateMetricWithAnimation('phase', j.phase, 'text');
    
    // Update risk values with animation
    updateMetricWithAnimation('risk', j.Risk.toFixed(3), 'number');
    
    // Update physical indices with animation
    updateMetricWithAnimation('cai', j.CAI.toFixed(3), 'number');
    updateMetricWithAnimation('cdi', j.CDI.toFixed(3), 'number');
    updateMetricWithAnimation('thi', j.THI.toFixed(3), 'number');
    updateMetricWithAnimation('ti', j.TI.toFixed(3), 'number');
    updateMetricWithAnimation('ei', j.EI.toFixed(3), 'number');

    // Update alert with animation
    const a = document.getElementById('alert');
    const alertChanged = a.textContent !== j.Alert;
    a.textContent = j.Alert;
    a.className = 'alert ' + j.Alert.toLowerCase();
    
    if (alertChanged) {
      a.style.transform = 'scale(1.1)';
      setTimeout(() => a.style.transform = 'scale(1)', 300);
    }
    
    // Add to chart data for real-time visualization
    if (realTimeMode) {
      chartData.push({
        timestamp: timestamp,
        risk: j.Risk,
        alert: j.Alert
      });
      
      // Keep only last maxDataPoints
      if (chartData.length > maxDataPoints) {
        chartData.shift();
      }
      
      drawRealTimeChart();
    }
    
    // Update status indicator to online
    document.querySelector('.status-indicator').className = 'status-indicator online';
    
  } catch(e) {
    console.error(e);
    // Update status indicator to offline
    document.querySelector('.status-indicator').className = 'status-indicator offline';
  }
}

function updateMetricWithAnimation(elementId, newValue, type) {
  const element = document.getElementById(elementId);
  const oldValue = previousValues[elementId];
  
  if (oldValue !== undefined && oldValue !== newValue) {
    // Add animation class
    element.style.transition = 'all 0.3s ease';
    element.style.transform = 'scale(1.05)';
    element.style.color = '#ff6b6b';
    
    setTimeout(() => {
      element.style.transform = 'scale(1)';
      element.style.color = '';
    }, 300);
  }
  
  if (type === 'number') {
    element.textContent = newValue;
  } else {
    element.textContent = newValue;
  }
  
  previousValues[elementId] = newValue;
}

function drawRealTimeChart() {
  if (chartData.length < 2) return;
  
  const canvas = document.getElementById('chart');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Set up chart dimensions
  const margin = {top: 30, right: 30, bottom: 50, left: 80};
  const chartWidth = canvas.width - margin.left - margin.right;
  const chartHeight = canvas.height - margin.top - margin.bottom;
  
  // Draw background
  ctx.fillStyle = '#f8f9fa';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw axes
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 2;
  ctx.beginPath();
  // Y-axis
  ctx.moveTo(margin.left, margin.top);
  ctx.lineTo(margin.left, margin.top + chartHeight);
  // X-axis
  ctx.moveTo(margin.left, margin.top + chartHeight);
  ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
  ctx.stroke();
  
  // Draw axis labels
  ctx.fillStyle = '#333';
  ctx.font = 'bold 16px Arial';
  ctx.textAlign = 'center';
  ctx.save();
  ctx.translate(20, margin.top + chartHeight/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText('Risk Level', 0, 0);
  ctx.restore();
  
  ctx.textAlign = 'center';
  ctx.fillText('Time â†’', margin.left + chartWidth/2, canvas.height - 10);
  
  // Draw Y-axis scale (0.0 to 1.0)
  ctx.font = '12px Arial';
  ctx.textAlign = 'right';
  for(let i = 0; i <= 5; i++) {
    const value = i * 0.2;
    const y = margin.top + chartHeight - (value * chartHeight);
    ctx.fillText(value.toFixed(1), margin.left - 10, y + 4);
    
    // Draw horizontal grid lines
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + chartWidth, y);
    ctx.stroke();
  }
  
  // Draw alert level thresholds
  const thresholds = [
    {level: 0.4, color: '#FFC107', label: 'Yellow Alert'},
    {level: 0.6, color: '#FF9800', label: 'Orange Alert'}, 
    {level: 0.75, color: '#F44336', label: 'Red Alert'}
  ];
  
  thresholds.forEach(t => {
    const y = margin.top + chartHeight - (t.level * chartHeight);
    ctx.strokeStyle = t.color;
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(margin.left, y);
    ctx.lineTo(margin.left + chartWidth, y);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Label threshold
    ctx.fillStyle = t.color;
    ctx.font = 'bold 11px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(t.label, margin.left + 5, y - 8);
  });
  
    // Plot Risk (blue line with gradient)
    if (chartData.length > 1) {
      ctx.strokeStyle = '#2196f3';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for(let i = 0; i < chartData.length; i++) {
        const x = margin.left + (i / (chartData.length - 1)) * chartWidth;
        const y = margin.top + chartHeight - (chartData[i].risk * chartHeight);
        if(i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();
      
      // Add data points
      chartData.forEach((point, i) => {
        const x = margin.left + (i / (chartData.length - 1)) * chartWidth;
        const y = margin.top + chartHeight - (point.risk * chartHeight);
        
        // Color based on alert level
        let color = '#4CAF50'; // green
        if (point.alert === 'yellow') color = '#FFC107';
        else if (point.alert === 'orange') color = '#FF9800';
        else if (point.alert === 'red') color = '#F44336';
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
      });
    }
  
  // (RiskExtended removed from visualization)

  // Draw legend
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#2196f3';
  ctx.fillText('Risk Level', margin.left + chartWidth - 120, margin.top + 20);
  
  // Add current values
  if (chartData.length > 0) {
    const latest = chartData[chartData.length - 1];
    ctx.fillStyle = '#333';
    ctx.font = 'bold 12px Arial';
    ctx.fillText(`Current: ${latest.risk.toFixed(3)}`, margin.left + chartWidth - 120, margin.top + 40);
  }
}

async function fetchHistoryAndPlot() {
  if (!realTimeMode) {
    try {
      const r = await fetch('/history?n=288');
      const arr = await r.json();
      chartData = arr.map(x => ({
        timestamp: new Date(x.timestamp),
        risk: x.Risk,
        alert: x.Alert
      }));
      drawRealTimeChart();
    } catch(e){ console.error(e); }
  }
}

// Control functions
function toggleRealTime() {
  realTimeMode = !realTimeMode;
  const btn = event.target;
  if (realTimeMode) {
    btn.textContent = 'Real-Time Mode';
    btn.classList.add('active');
    chartData = []; // Clear data for fresh start
  } else {
    btn.textContent = 'Historical Mode';
    btn.classList.remove('active');
    fetchHistoryAndPlot();
  }
}

function downloadData() {
  const dataStr = JSON.stringify(chartData, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'ews_realtime_data.json';
  link.click();
  URL.revokeObjectURL(url);
}

function resetChart() {
  chartData = [];
  drawRealTimeChart();
}

fetchStatus();
fetchHistoryAndPlot();
setInterval(fetchStatus, 2000); // Update every 2 seconds for more dynamic feel
setInterval(fetchHistoryAndPlot, 10000); // Update history every 10 seconds
</script>
</body>
</html>
